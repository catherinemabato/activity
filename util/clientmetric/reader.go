package clientmetric

import (
	"sort"
	"strings"
	"fmt"
	"io"
	"log"
	"encoding/binary"
	"encoding/hex"
)

// Reader decodes metric updates that were generated by
// EncodeLogTailMetricsDelta. It's stateful: multiple deltas can be
// pased to it, with the current values of metrics being updated.
type Reader struct {
	val  map[int64]int64  // wire-id to value
	name map[int64]string // wire-id to name
}

// NewReader configures an empty reader.
func NewReader() *Reader {
	r := &Reader{}
	r.Reset()
	return r
}

// Reset clears the state of the reader.
func (r *Reader) Reset() {
	r.val = map[int64]int64{}
	r.name = map[int64]string{}
}

// IsEmpty checks if this reader has accumulated any metrics data.
func (r *Reader) IsEmpty() bool {
	return len(r.val) == 0
}

// GetAll returns all the metrics that have been accumulated.
func (r *Reader) GetAll() map[string]int64 {
	m := make(map[string]int64)
	for id, n := range r.name {
		m[n] = r.val[id]
	}
	return m
}

// Get returns a single metric that has been read, and a flag if it's an unknown
// metric. It is inefficient, GetAll() should be used for bulk access.
func (r *Reader) Get(name string) (value int64, ok bool) {
	for id, n := range r.name {
		if n == name {
			return r.val[id], true
		}
	}
	return 0, false
}

// Dump prints out all metrics that have been accumulated. Meant for debugging
// use only.
func (r *Reader) Dump() {
	var keys []int64
	for id := range r.name {
		keys = append(keys, id)
	}
	sort.Slice(keys, func(i, j int) bool { return r.name[keys[i]] < r.name[keys[j]] })
	for _, id := range keys {
		fmt.Printf("  %10d %s\n", r.val[id], r.name[id])
	}
}

// Update reads the hex-encoded packed encoded `input` and updates metrics with
// new and changed metrics.
func (r *Reader) Update(input string) {
	r.UpdateWithHook(input, nil)
}

type updateHook func(name string, value int64, delta int64)

// Update reads the hex-encoded packed encoded `input` and updates metrics with
// new and changed metrics. `hook` is invoked when metrics are set or
// incremented.
func (r *Reader) UpdateWithHook(input string, hook updateHook) {
	inputReader := strings.NewReader(input)
	var byteReader io.ByteReader = byteFromHexReader{inputReader}
	var nextName string
	for {
		op, err := inputReader.ReadByte()
		if err == io.EOF {
			return
		}
		if err != nil {
			log.Printf("metrics error: %v", err)
			return
		}
		switch op {
		case 'N':
			// "Name" op. Sets the name of the metric in the immediately
			// following "S" (set) or "I" (increment op). Encoding is
			// hex(varint) length, followed by that many bytes.
			n, err := binary.ReadVarint(byteReader)
			if err != nil {
				log.Printf("varint-after-N error: %v", err)
				return
			}
			if n > 1000 {
				log.Printf("unexpectedly large string length %v", n)
				return
			}
			if n < 1 {
				log.Printf("unexpectedly small name length %v", n)
				return
			}
			name := make([]byte, n)
			if _, err := io.ReadFull(inputReader, name); err != nil {
				log.Printf("reading metric name: %v", err)
				return
			}
			nextName = string(name)
		case 'S', 'I':
			// Set/increment value: varint-encoded id,
			// then varint-encoded set/incr value.
			id, err := binary.ReadVarint(byteReader)
			if err != nil {
				return
			}
			v, err := binary.ReadVarint(byteReader)
			if err != nil {
				return
			}
			var name string
			if nextName != "" {
				name = nextName
				r.name[id] = nextName
				nextName = ""
			}
			var cur int64
			switch op {
			case 'S': // set
				cur = v
			case 'I': // incr
				if old, ok := r.val[id]; ok {
					cur = old + v
				} else {
					// We don't have an initial value to adjust here.
					// We may have arrived mid-stream.
					// Ignore this metric until we reach a set op for it.
					continue
				}
			}
			r.val[id] = cur
			ok := name != ""
			if !ok {
				name, ok = r.name[id]
			}
			if ok && hook != nil {
				if op == 'I' {
					hook(name, cur, v)
				} else {
					hook(name, cur, 0)
				}
			}

		default:
			log.Printf("unknown op %q", rune(op))
		}
	}
}

type byteFromHexReader struct{ r io.ByteReader }

func (b byteFromHexReader) ReadByte() (_ byte, err error) {
	var x [2]byte
	x[0], err = b.r.ReadByte()
	if err != nil {
		return
	}
	x[1], err = b.r.ReadByte()
	if err != nil {
		return
	}
	_, err = hex.Decode(x[:1], x[:2])
	return x[0], err
}
